<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Visor de Producto</title>
  <style>
    body {
      margin: 0;
    }
  </style>
</head>

<body>
  <div class="sable">
    <div>Sable</div>
    <a class="prev" onclick="plusBlade(-1)">&#10094;</a>
    <a class="next" onclick="plusBlade(1)">&#10095;</a>
  </div>
  <div class="vaina">
    <div>Vaina</div>
    <a class="prev" onclick="plusVaina(-1)">&#10094;</a>
    <a class="next" onclick="plusVaina(1)">&#10095;</a>
  </div>
  <div class="Empunadura">
    <div>Empunadura</div>
    <a class="prev" onclick="plusEmpunadura(-1)">&#10094;</a>
    <a class="next" onclick="plusEmpunadura(1)">&#10095;</a>
  </div>
  <div class="Texturas">
    <div>Sables Texturas</div>
    <a class="prev" onclick="plusTexturaSable(-1)">&#10094;</a>
    <a class="next" onclick="plusTexturaSable(1)">&#10095;</a>
  </div>
  <div class="Texturas">
    <div>Vaina Texturas</div>
    <a class="prev" onclick="plusTexturaVaina(-1)">&#10094;</a>
    <a class="next" onclick="plusTexturaVaina(1)">&#10095;</a>
  </div>

  <!-- Scripts   -->
  <script src="js/three.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/OBJLoader.js"></script>
  <script src="js/RGBELoader.js"></script>

  <script>


    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );

    const manos = [];
    const sable = [];
    const baqueta = [];

    const Texts = [];

    //Vaina Texturas
    const AllVainas_Texture = [];

    

    const Vainas_TexturesNormal = [];
    AllVainas_Texture.push(Vainas_TexturesNormal);
    const Vainas_TexturesSakura = [];
    AllVainas_Texture.push(Vainas_TexturesSakura);
    const Vainas_TexturesBlack = [];
    AllVainas_Texture.push(Vainas_TexturesBlack);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    //Iluminacion
    const spotLight = new THREE.SpotLight(0xffffff, 40, 146);
    scene.add(spotLight);
    const light = new THREE.AmbientLight(0x404040, 2); // soft white light
    scene.add(light);


    spotLight.position.set(0, 100, 100);
    spotLight.castShadow = true;
    scene.add(spotLight);
    const spotLightHelper = new THREE.SpotLightHelper(spotLight);
    scene.add(spotLightHelper);


    //Suelo de Tatami
    const texture = new THREE.TextureLoader().load("textures/tatami.jpg");
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(2, 2);

    const material2 = new THREE.MeshBasicMaterial({
      map: texture,
      side: THREE.DoubleSide,
    });
    const planegeometry = new THREE.PlaneGeometry(50, 50);
    const plane = new THREE.Mesh(planegeometry, material2);
    plane.receiveShadow = true;
    plane.castShadow = true;
    scene.add(plane);
    plane.rotation.x = Math.PI / 2;
    plane.position.y = -1;
    plane.position.z = -0.5;

    const loaderr = new THREE.TextureLoader();
    let fondo = loaderr.load("textures/japanese_wall.jpg");
    scene.background = fondo;

    //Carga de Texturas y Materiales


    //Textura de la Hoja de la Espada
    const options = {
      enableSwoopingCamera: false,
      enableRotation: true,
      transmission: 1,
      thickness: 1.2,
      roughness: 0.6,
      envMapIntensity: 1.5,
      clearcoat: 1,
      clearcoatRoughness: 0.1,
      normalScale: 1,
      clearcoatNormalScale: 0.3,
      normalRepeat: 1
    };

    const hdrEquirect = new THREE.RGBELoader().load(
      "textures/sepulchral_chapel_rotunda_2k.hdr",
      () => {
        hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;
      }
    );


    const normalMapTexture = new THREE.TextureLoader().load("textures/rugoso.jpg");
    normalMapTexture.wrapS = THREE.RepeatWrapping;
    normalMapTexture.wrapT = THREE.RepeatWrapping;
    normalMapTexture.repeat.set(options.normalRepeat, options.normalRepeat);


    const texturewood = new THREE.TextureLoader().load("Materiales/bamboo-wood-semigloss-normal.png");
    texturewood.wrapS = THREE.RepeatWrapping;
    texturewood.wrapT = THREE.RepeatWrapping;
    texturewood.repeat.set(options.normalRepeat, options.normalRepeat);
    const texturewood2 = new THREE.TextureLoader().load("textures/bamboo-wood-semigloss-albedo.png");

    const TextureMadera = new THREE.MeshPhysicalMaterial({
      map: texturewood2,

      transmission: options.transmission,
      thickness: options.thickness,
      roughness: 1,

      envMapIntensity: options.envMapIntensity,

      normalScale: new THREE.Vector2(options.normalScale),
      normalMap: texturewood,
      clearcoatNormalMap: texturewood,
      clearcoatNormalScale: new THREE.Vector2(options.clearcoatNormalScale),
      side: THREE.DoubleSide
    });
    Texts.push(TextureMadera);

    const texturemetal = new THREE.TextureLoader().load("Materiales/reinforced-metal_normal-dx.png");
    const texturemetal2 = new THREE.TextureLoader().load("textures/reinforced-metal_albedo.png");
    texturemetal.wrapS = THREE.RepeatWrapping;
    texturemetal.wrapT = THREE.RepeatWrapping;
    texturemetal.repeat.set(options.normalRepeat, options.normalRepeat);



    const TextureM = new THREE.MeshPhysicalMaterial({

      map: texturemetal2,
      roughness: 0,
      metalness: 0.8,
      envMap: hdrEquirect,
      envMapIntensity: options.envMapIntensity,
      clearcoat: options.clearcoat,
      clearcoatRoughness: options.clearcoatRoughness,
      normalScale: new THREE.Vector2(options.normalScale),
      normalMap: texturemetal,
      clearcoatNormalMap: texturemetal,
      clearcoatNormalScale: new THREE.Vector2(options.clearcoatNormalScale)

    });
    Texts.push(TextureM);

    const CristalTexture = new THREE.MeshPhysicalMaterial({
      transmission: options.transmission,
      thickness: options.thickness,
      roughness: options.roughness,

      envMapIntensity: options.envMapIntensity,
      clearcoat: options.clearcoat,
      clearcoatRoughness: options.clearcoatRoughness,
      normalScale: new THREE.Vector2(options.normalScale),
      normalMap: normalMapTexture,
      clearcoatNormalMap: normalMapTexture,
      clearcoatNormalScale: new THREE.Vector2(options.clearcoatNormalScale)
    });
    Texts.push(CristalTexture);


    //Textura de la Vaina de la Espada

    //Sakura

    const TextureSakura1 = new THREE.TextureLoader().load("textures/texturesSakura/Katana_MAT_BaseColor.jpg");


    TextureSakura1.repeat.set(options.normalRepeat, options.normalRepeat);
    const VainaT1 = new THREE.MeshPhysicalMaterial({
      map: TextureSakura1,

      transmission: options.transmission,
      thickness: options.thickness,
      roughness: 1,



      side: THREE.DoubleSide
    });
    Vainas_TexturesSakura.push(VainaT1);


    const TextureSakura2 = new THREE.TextureLoader().load("textures/texturesSakura/Albedo - copia.png");

    const VainaT2 = new THREE.MeshPhysicalMaterial({
      map: TextureSakura2,

      transmission: options.transmission,
      thickness: options.thickness,
      roughness: 1,



      side: THREE.DoubleSide
    });
    Vainas_TexturesSakura.push(VainaT2);


    //Normal


    const TextureNormal1 = new THREE.TextureLoader().load("textures/texturesNormal/Katana_MAT_BaseColor2.jpg");


    TextureNormal1.repeat.set(options.normalRepeat, options.normalRepeat);
    const VainaNormal1 = new THREE.MeshPhysicalMaterial({
      map: TextureNormal1,

      transmission: options.transmission,
      thickness: options.thickness,
      roughness: 1,



      side: THREE.DoubleSide
    });
    Vainas_TexturesNormal.push(VainaNormal1);

 
    const TextureNormal2 = new THREE.TextureLoader().load("textures/texturesNormal/Albedo.png");

    const VainaNormal2 = new THREE.MeshPhysicalMaterial({
      map: TextureNormal2,

      transmission: options.transmission,
      thickness: options.thickness,
      roughness: 1,



      side: THREE.DoubleSide
    });
    Vainas_TexturesNormal.push(VainaNormal2);

    //Black

    const TextureBlack1 = new THREE.TextureLoader().load("textures/texturesNormal/Katana_MAT_BaseColor2.jpg");


    TextureBlack1.repeat.set(options.normalRepeat, options.normalRepeat);
    const VainaBlack1 = new THREE.MeshPhysicalMaterial({
      map: TextureBlack1,

      transmission: options.transmission,
      thickness: options.thickness,
      roughness: 1,



      side: THREE.DoubleSide
    });
    Vainas_TexturesBlack.push(VainaBlack1);

 
    const TextureBlack2 = new THREE.TextureLoader().load("textures/texturesNormal/Albedo.png");

    const VainaBlack2 = new THREE.MeshPhysicalMaterial({
      map: TextureBlack2,

      transmission: options.transmission,
      thickness: options.thickness,
      roughness: 1,



      side: THREE.DoubleSide
    });
    Vainas_TexturesBlack.push(VainaBlack2);





    //Carga de modelos y configuracion

    //Stand de modelaje
    const Stand = new THREE.OBJLoader();
    Stand.load("models/standSmall_LOD0.obj", function (object) {
      //     console.log(object.children[0]);
      const estante = object.children[0];
      estante.material = new THREE.MeshPhysicalMaterial({
        color: "blue",
      });

      estante.scale.x = 6;
      estante.scale.y = 6;
      estante.scale.z = 6;
      estante.position.y = -1;

      scene.add(estante);
    });

    //Espada

    const Blade1 = new THREE.OBJLoader();
    Blade1.load("models/Katana_export.obj", function (object) {
      Blade = object.children[0];

      Blade.material = TextureMadera;

      Blade.scale.x = 2;
      Blade.scale.y = 2;
      Blade.scale.z = 2;

      Blade.position.y = 0.1;
      Blade.rotation.z = Math.PI / -2;
      Blade.rotation.y = Math.PI;
      sable.push(Blade);
      scene.add(sable[0]);
    });

    // BladeCiber
    const Blade2 = new THREE.OBJLoader();
    Blade2.load("models/KatanaForZIP2.obj", function (object) {
      const BladeCiber = object.children[0];

      BladeCiber.material = TextureMadera;
      BladeCiber.scale.x = 0.4;
      BladeCiber.scale.y = 0.4;
      BladeCiber.scale.z = 0.4;
      BladeCiber.rotation.y = Math.PI / 2;

      BladeCiber.position.y = 0.2;
      BladeCiber.position.x = 0;
      sable.push(BladeCiber);
    });

    //BladeSakura
    const Blade3 = new THREE.OBJLoader();
    Blade3.load("models/Katana4.obj", function (object) {
      const BladeSakura = object.children[0];
      BladeSakura.material = TextureMadera

      BladeSakura.scale.x = 2;
      BladeSakura.scale.y = 2;
      BladeSakura.scale.z = 2;

      BladeSakura.position.y = 0.1;
      BladeSakura.position.x = -0.5;
      sable.push(BladeSakura);
    });

    // BladeBlack
    const Blade4 = new THREE.OBJLoader();
    Blade4.load("models/BlackKatana.obj", function (object) {
      const BladeBlack = object.children[2];
      BladeBlack.material = TextureMadera
      BladeBlack.scale.x = 2;
      BladeBlack.scale.y = 2;
      BladeBlack.scale.z = 2;
      BladeBlack.rotation.z = Math.PI / 0.98;
      BladeBlack.rotation.x = Math.PI / 0.98;
      BladeBlack.position.y = -0.6;
      BladeBlack.position.x = -0.4;
      BladeBlack.position.z = -0.05;
      sable.push(BladeBlack);
    });

    //Vaina
    const Vaina1 = new THREE.OBJLoader();
    Vaina1.load("models/Katana_vaina.obj", function (object) {
      const Vaina = object.children[1];
      Vaina.material = VainaT1;
      Vaina.scale.x = 2;
      Vaina.scale.y = 2;
      Vaina.scale.z = 2;
      Vaina.rotation.z = Math.PI / 1.82;

      Vaina.position.y = -0.37;
      Vaina.position.x = -0.2;


      baqueta.push(Vaina);
    });

    // Vaina Sakura
    const Vaina2 = new THREE.OBJLoader();
    Vaina2.load("models/Katana.obj", function (object) {
      VainaSakura = object.children[1];
      VainaSakura.material = new THREE.MeshPhysicalMaterial({ color: "red" });
      VainaSakura.scale.x = 0.02;
      VainaSakura.scale.y = 0.02;
      VainaSakura.scale.z = 0.02;

      VainaSakura.position.y = -0.37;
      VainaSakura.position.x = -1;

      baqueta.push(VainaSakura);
    });

    // Black Vaina
    const Vaina3 = new THREE.OBJLoader();
    Vaina3.load("models/BlackKatana.obj", function (object) {
      const BlackVaina = object.children[0];
      BlackVaina.material = VainaT1;
      BlackVaina.scale.x = 2;
      BlackVaina.scale.y = 2;
      BlackVaina.scale.z = 2;
      BlackVaina.rotation.z = Math.PI / 0.98;
      BlackVaina.position.y = 0.02;
      BlackVaina.position.x = -0.4;
      scene.add(BlackVaina);
      baqueta.push(BlackVaina);
    });

    //Agarres

    // Black Agarre
    const Empunadura1 = new THREE.OBJLoader();
    Empunadura1.load("models/BlackKatana.obj", function (object) {
      const BlackEmpunadura = object.children[1];
      BlackEmpunadura.material = new THREE.MeshPhysicalMaterial({ color: "red" });
      BlackEmpunadura.scale.x = 2;
      BlackEmpunadura.scale.y = 2;
      BlackEmpunadura.scale.z = 2;
      BlackEmpunadura.rotation.z = Math.PI / 1.02;
      BlackEmpunadura.position.y = 0.78;
      BlackEmpunadura.position.x = 0.3;
      // scene.add(BlackEmpunadura);
      manos.push(BlackEmpunadura);
    });

    //AgarreNormal 
    const Empunadura2 = new THREE.OBJLoader();
    Empunadura2.load("models/Empunadura1.obj", function (object) {
      const Empunadura = object.children[0];
      Empunadura.material = new THREE.MeshPhysicalMaterial({ color: "red" });
      Empunadura.scale.x = 2;
      Empunadura.scale.y = 2;
      Empunadura.scale.z = 2;
      Empunadura.rotation.z = Math.PI / 2;
      Empunadura.rotation.x = Math.PI;
      Empunadura.position.y = 0.12;
      Empunadura.position.x = 0;

      manos.push(Empunadura);
    });

    //AgarreCibber
    const Empunadura3 = new THREE.OBJLoader();
    Empunadura3.load("models/KatanaForZIPAgarre.obj", function (object) {
      const EmpunaduraCiber = object.children[0];
      EmpunaduraCiber.material = new THREE.MeshPhysicalMaterial({ color: "red" });
      EmpunaduraCiber.scale.x = 0.4;
      EmpunaduraCiber.scale.y = 0.4;
      EmpunaduraCiber.scale.z = 0.4;
      EmpunaduraCiber.rotation.z = Math.PI;
      EmpunaduraCiber.rotation.x = Math.PI;
      EmpunaduraCiber.rotation.y = Math.PI / 2;
      EmpunaduraCiber.position.y = 0.18;
      EmpunaduraCiber.position.x = 0;

      manos.push(EmpunaduraCiber);
      scene.add(EmpunaduraCiber);
    });









    //Funcion de Paso de Espada

    let slideIndex = 0;
    showBlade(slideIndex);

    // Next/previous controls
    function plusBlade(n) {
      showBlade((slideIndex += n));
    }

    function showBlade(n) {
      if (n >= sable.length) {
        slideIndex = 0;
      }

      if (n < 0) {
        slideIndex = sable.length - 1;
      }

      for (let index = 0; index < sable.length; index++) {
        const element = sable[index];

        if (index == slideIndex) {
          scene.add(element);
        } else {
          scene.remove(element);
        }
      }
    }


    //Funcion de Paso de Espada

    let slideAgarre = 0;
    showEmpunadura(slideAgarre);

    // Next/previous controls
    function plusEmpunadura(n) {
      showEmpunadura((slideAgarre += n));
    }

    function showEmpunadura(n) {
      if (n >= manos.length) {
        slideAgarre = 0;
      }

      if (n < 0) {
        slideAgarre = manos.length - 1;
      }

      for (let index = 0; index < manos.length; index++) {
        const element = manos[index];

        if (index == slideAgarre) {
          scene.add(element);
        } else {
          scene.remove(element);
        }
      }
    }

    //Funcion paso de vaina
    let slideVaina = 0;

    // Next/previous controls
    function plusVaina(n) {
      showVaina((slideVaina += n));
    }

    function showVaina(n) {
      if (n >= baqueta.length) {
        slideVaina = 0;
      }

      if (n < 0) {
        slideVaina = baqueta.length - 1;
      }

      for (let index = 0; index <= baqueta.length; index++) {
        const element = baqueta[index];

        if (index == slideVaina) {
          scene.add(element);
        } else {
          scene.remove(element);
        }
      }
    }

    //Funcion paso de Textura al Sable
    let slideTextura = 0;

    // Next/previous controls
    function plusTexturaSable(n) {
      TexturaSable((slideTextura += n));
    }

    function TexturaSable(n) {
      if (n >= Texts.length) { slideTextura = 0; }

      if (n < 0) { slideTextura = Texts.length - 1; }



      for (let index = 0; index < sable.length; index++) {

        if (Texts[slideTextura].isMaterial == true) {
        
          sable[index].material = Texts[slideTextura]
        }
        else {
          sable[index].material = new THREE.MeshPhysicalMaterial({ map: Texts[slideTextura] });
        }


      }
    }


    //Funcion paso de Textura a la Vaina
    let slideTexturaVaina = 0;

    // Next/previous controls
    function plusTexturaVaina(n) {
      TexturaVaina((slideTexturaVaina += n));
    }

    function TexturaVaina(n) {
      if (n >= Vainas_TexturesSakura.length) { slideTexturaVaina = 0; }

      if (n < 0) { slideTexturaVaina = Vainas_TexturesSakura.length - 1; }



    
        for (let index = 0; index < Vainas_TexturesSakura.length; index++) {
          console.log("hola")
          console.log(AllVainas_Texture)
          for (let index = 0; index < baqueta.length; index++) {
            if (Vainas_TexturesSakura[slideTexturaVaina].isMaterial == true) {
              baqueta[index].material = AllVainas_Texture[index][slideTexturaVaina]
              console.log(AllVainas_Texture[slideVaina][slideTexturaVaina])
              //Vainas_TexturesSakura[slideTexturaVaina]
            }
            else {
              baqueta[index].material = new THREE.MeshPhysicalMaterial({ map: Vainas_TexturesSakura[slideTexturaVaina] });
            }

          }
        }
    

    }





    //general configs

    camera.position.z = 5;
    const control = new THREE.OrbitControls(camera, renderer.domElement);
    control.update();

    function animate() {
      requestAnimationFrame(animate);

      control.update();

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>

</html>